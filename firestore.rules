rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    match /events/{eventId} {
      allow read: if true;
      allow create: if isAuthenticated();
      allow update: if isAuthenticated() && 
        (resource.data.hostId == request.auth.uid || 
         request.resource.data.hostId == request.auth.uid);
      allow delete: if isAuthenticated() && resource.data.hostId == request.auth.uid;
    }
    
    match /users/{userId} {
      // Allow reading user profiles for:
      // 1. Own profile (authenticated users)
      // 2. Public profiles (isPublic == true)
      // 3. Profiles of event hosts (for displaying host info on events - public read)
      // This ensures host names and profile pictures are visible on events even when not logged in
      allow read: if true; // Allow public read for event host display
      allow create: if isAuthenticated() && userId == request.auth.uid;
      // UPDATE: User can update own profile fully, OR any user can update followers array (for follow system)
      allow update: if isAuthenticated() && (
        // Own profile - full update allowed
        userId == request.auth.uid ||
        // Other users can ONLY update followers array (follow/unfollow)
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['followers'])
      );
      allow delete: if isAuthenticated() && userId == request.auth.uid;
      
      // Notifications subcollection - users can read/write their own notifications
      // Other authenticated users can CREATE notifications for this user (for sending notifications)
      match /notifications/{notificationId} {
        allow read: if isAuthenticated() && userId == request.auth.uid;
        allow create: if isAuthenticated(); // Any authenticated user can send a notification
        allow update: if isAuthenticated() && userId == request.auth.uid;
        allow delete: if isAuthenticated() && userId == request.auth.uid;
      }
    }
    
    match /reservations/{reservationId} {
      // READ: reservation owner OR event host
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        get(/databases/$(database)/documents/events/$(resource.data.eventId)).data.hostId == request.auth.uid
      );

      // CREATE: only the user creating their own reservation
      allow create: if isAuthenticated() &&
        request.resource.data.userId == request.auth.uid;

      // UPDATE: field-level restrictions
      allow update: if isAuthenticated() && (
        // Attendee can update cancellation + subscription opt-out fields only
        (resource.data.userId == request.auth.uid &&
         request.resource.data.diff(resource.data).affectedKeys()
           .hasOnly(['status', 'cancelledAt', 'cancelledByUid', 'optOutRequested', 'optOutProcessed']))
        ||
        // Host can update check-in + expulsion fields only
        (get(/databases/$(database)/documents/events/$(resource.data.eventId)).data.hostId == request.auth.uid &&
         request.resource.data.diff(resource.data).affectedKeys()
           .hasOnly(['checkedInAt', 'checkedInBy', 'status', 'cancelledAt', 'cancelledBy', 'cancellationReason']))
      );

      // DELETE: reservation owner OR event host
      allow delete: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        get(/databases/$(database)/documents/events/$(resource.data.eventId)).data.hostId == request.auth.uid
      );
    }
    
    match /reviews/{reviewId} {
      allow read: if true;
      allow create: if isAuthenticated();
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    match /newsletter_subscribers/{subscriberId} {
      allow read: if isAuthenticated();
      allow create: if true;
      allow update: if isAuthenticated();
      allow delete: if isAuthenticated();
    }
    
    match /contact_inquiries/{inquiryId} {
      allow read: if isAuthenticated();
      allow create: if true;
      allow update: if isAuthenticated();
      allow delete: if isAuthenticated();
    }
    
    match /reports/{reportId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated();
      allow update: if isAuthenticated();
      allow delete: if isAuthenticated();
    }
    
    match /events/{eventId}/{document=**} {
      allow read: if isAuthenticated();
      allow write: if isAuthenticated();
    }
    
    match /events/{eventId}/reviews/{reviewId} {
      allow read: if true;
      allow create: if isAuthenticated();
      // Allow update by reviewer OR event host (for accepting/contesting reviews)
      allow update: if isAuthenticated() && 
        (resource.data.userId == request.auth.uid || 
         get(/databases/$(database)/documents/events/$(eventId)).data.hostId == request.auth.uid);
      // Allow delete by reviewer OR event host (for managing reviews)
      allow delete: if isAuthenticated() && 
        (resource.data.userId == request.auth.uid || 
         get(/databases/$(database)/documents/events/$(eventId)).data.hostId == request.auth.uid);
    }
    
    match /events/{eventId}/messages/{messageId} {
      // CRITICAL: Allow read for ALL authenticated users (host and attendees)
      // This ensures host can see all messages, and attendees can see all messages
      // The app logic handles access control (who can access the chat)
      allow read: if isAuthenticated();
      // CRITICAL: Check both senderId (primary) and userId (backward compatibility)
      // Both fields are guaranteed to be set by addChatMessage()
      allow create: if isAuthenticated() && 
        (request.resource.data.senderId == request.auth.uid || 
         request.resource.data.userId == request.auth.uid);
      allow update: if isAuthenticated() && 
        (resource.data.senderId == request.auth.uid || 
         resource.data.userId == request.auth.uid);
      allow delete: if isAuthenticated() && 
        (resource.data.senderId == request.auth.uid || 
         resource.data.userId == request.auth.uid);
    }
    
    match /events/{eventId}/expulsions/{expulsionId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && 
        get(/databases/$(database)/documents/events/$(eventId)).data.hostId == request.auth.uid;
      allow update: if isAuthenticated() && 
        get(/databases/$(database)/documents/events/$(eventId)).data.hostId == request.auth.uid;
      allow delete: if isAuthenticated() && 
        get(/databases/$(database)/documents/events/$(eventId)).data.hostId == request.auth.uid;
    }
    
    // Phone verification codes - users can only create/read/delete their own codes
    match /phone_verification_codes/{userId} {
      allow read: if isAuthenticated() && userId == request.auth.uid;
      allow create: if isAuthenticated() && userId == request.auth.uid;
      allow update: if isAuthenticated() && userId == request.auth.uid;
      allow delete: if isAuthenticated() && userId == request.auth.uid;
    }
    
    // Email logs - authenticated users can create logs, read is restricted
    match /email_logs/{logId} {
      allow read: if false; // Admin only - not accessible from client
      allow create: if isAuthenticated(); // Allow logging email attempts
      allow update: if false;
      allow delete: if false;
    }
    
    // SMS logs - authenticated users can create logs, read is restricted
    match /sms_logs/{logId} {
      allow read: if false; // Admin only - not accessible from client
      allow create: if isAuthenticated(); // Allow logging SMS attempts
      allow update: if false;
      allow delete: if false;
    }
    
    // Payments collection - for tracking payment records
    match /payments/{paymentId} {
      allow read: if isAuthenticated() && 
        (resource.data.userId == request.auth.uid || 
         resource.data.hostId == request.auth.uid);
      allow create: if isAuthenticated();
      allow update: if false; // Only webhooks can update
      allow delete: if false;
    }
    
    // Announcements - for event announcements and polls
    match /announcements/{eventId}/items/{announcementId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated();
      allow update: if isAuthenticated();
      allow delete: if isAuthenticated();
      
      // Votes subcollection for polls
      match /votes/{voteId} {
        allow read: if isAuthenticated();
        allow create: if isAuthenticated() && voteId == request.auth.uid;
        allow update: if false; // No changing votes
        allow delete: if false;
      }
    }
    
    // Marketing campaigns - admin only (eatezca@gmail.com)
    // Client-side can create/update drafts, but bulk sending is server-side only
    match /marketing_campaigns/{campaignId} {
      // Only allow access if user email is the admin
      allow read: if isAuthenticated() && 
        request.auth.token.email == 'eatezca@gmail.com';
      allow create: if isAuthenticated() && 
        request.auth.token.email == 'eatezca@gmail.com';
      allow update: if isAuthenticated() && 
        request.auth.token.email == 'eatezca@gmail.com';
      allow delete: if isAuthenticated() && 
        request.auth.token.email == 'eatezca@gmail.com';
    }
    
    // Marketing campaign logs - server-side only (via Admin SDK)
    match /marketing_campaigns_log/{logId} {
      allow read: if false;
      allow write: if false;
    }
    
    // Email unsubscribes - server-side only (via Admin SDK)
    match /email_unsubscribes/{docId} {
      allow read: if false;
      allow write: if false;
    }
  }
}

